<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Editor (with Rich Text)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- pdf.js for rendering PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <!-- pdf-lib.js for creating and modifying PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <!-- Font for the UI -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <script>
        // Configure Tailwind to use class-based dark mode
        tailwind.config = {
          darkMode: 'class',
        }
        // Apply theme from localStorage on page load. Default to light mode.
        if (localStorage.getItem('color-theme') === 'dark') {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark')
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #canvas-wrapper {
            position: relative;
            width: 100%;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-radius: 0.5rem;
            background-color: #f1f5f9;
            line-height: 0;
        }
        .dark #canvas-wrapper {
            background-color: #1e293b;
        }
        #pdf-canvas, #objects-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #objects-canvas.draw-mode {
            cursor: crosshair;
        }
        #signature-canvas {
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            cursor: crosshair;
            background-color: #ffffff;
        }
        .dark #signature-canvas {
            border-color: #475569;
        }
        /* Style for active toggle buttons */
        .btn-toggle-active {
            background-color: #3b82f6 !important;
            color: white !important;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 dark:bg-slate-900 dark:text-slate-200 transition-colors duration-300">

    <!-- Initial Upload Screen -->
    <div id="upload-screen" class="min-h-screen flex items-center justify-center p-4">
        <div class="bg-white dark:bg-slate-800 p-8 md:p-12 rounded-xl shadow-2xl text-center max-w-lg w-full">
            <h1 class="text-4xl font-bold text-slate-900 dark:text-slate-100 mb-2">PDF Editor</h1>
            <p class="text-slate-600 dark:text-slate-400 mb-8">Start by selecting a PDF file from your device.</p>
            <label for="initial-pdf-upload" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 cursor-pointer inline-block">
                Select PDF to Start Editing
            </label>
            <input type="file" id="initial-pdf-upload" accept=".pdf" class="hidden">
        </div>
    </div>

    <!-- Main Editor Interface (Initially Hidden) -->
    <div id="main-editor" class="container mx-auto p-4 lg:p-8 hidden">
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
            
            <!-- Controls Sidebar (Toolbar) -->
            <aside class="lg:col-span-1 bg-white dark:bg-slate-800 p-6 rounded-lg shadow-md h-fit">
                <!-- Theme Switcher -->
                <div class="flex justify-between items-center mb-4 pb-4 border-b border-slate-200 dark:border-slate-700">
                    <span class="text-lg font-medium text-slate-700 dark:text-slate-300">Dark Mode</span>
                    <label for="theme-switch" class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="theme-switch" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                    </label>
                </div>

                <!-- File Info -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium text-slate-700 dark:text-slate-300 mb-2">File & History</h3>
                    <p id="pdf-filename" class="text-sm text-slate-600 dark:text-slate-400 bg-slate-100 dark:bg-slate-700 p-2 rounded-md truncate">No file loaded.</p>
                    <div class="grid grid-cols-2 gap-2 mt-3">
                        <button id="undo-btn" class="text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-300 font-semibold py-2 px-4 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">Undo</button>
                        <button id="redo-btn" class="text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-300 font-semibold py-2 px-4 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">Redo</button>
                    </div>
                    <button id="load-new-pdf-btn" class="w-full mt-2 text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-300 font-semibold py-2 px-4 rounded-lg transition duration-300">Load New PDF</button>
                </div>

                <!-- Mode Selector -->
                <div class="mb-6 border-t border-slate-200 dark:border-slate-700 pt-4">
                    <h3 class="text-lg font-medium text-slate-700 dark:text-slate-300 mb-3">Editing Mode</h3>
                    <div class="flex rounded-md shadow-sm" role="group">
                        <button type="button" id="select-mode-btn" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-blue-700 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:hover:text-white dark:hover:bg-gray-600 dark:focus:ring-blue-500">
                            Select
                        </button>
                        <button type="button" id="draw-mode-btn" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-r border-gray-200 hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-blue-700 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:hover:text-white dark:hover:bg-gray-600 dark:focus:ring-blue-500">
                            Draw / Whiteout
                        </button>
                    </div>
                </div>

                <!-- Add Elements (Select Mode) -->
                <div id="add-elements-panel" class="mb-6 border-t border-slate-200 dark:border-slate-700 pt-4">
                    <h3 class="text-lg font-medium text-slate-700 dark:text-slate-300 mb-3">Add Elements</h3>
                    <div class="space-y-3">
                        <button id="add-text-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Add Text</button>
                        <div>
                           <label for="image-upload" class="w-full text-center bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 cursor-pointer inline-block">Add Image</label>
                           <input type="file" id="image-upload" accept="image/png, image/jpeg" class="hidden">
                        </div>
                        <button id="add-signature-btn" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Add Signature</button>
                    </div>
                </div>

                <!-- Draw Settings (Draw Mode) -->
                <div id="draw-settings-panel" class="mb-6 border-t border-slate-200 dark:border-slate-700 pt-4 hidden">
                    <h3 class="text-lg font-medium text-slate-700 dark:text-slate-300 mb-3">Draw Settings</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="draw-color-input" class="block text-sm font-medium text-slate-700 dark:text-slate-400">Brush Color</label>
                            <div class="flex items-center space-x-2 mt-1">
                                <input type="color" id="draw-color-input" value="#000000" class="w-10 h-10 rounded-md border-slate-300 dark:border-slate-600 shadow-sm">
                                <button id="match-bg-btn" class="flex-1 text-xs bg-slate-200 hover:bg-slate-300 text-slate-700 dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-300 font-semibold py-2 px-2 rounded-lg">Match Page BG</button>
                            </div>
                        </div>
                        <div>
                            <label for="draw-size-input" class="block text-sm font-medium text-slate-700 dark:text-slate-400">Brush Size</label>
                            <input type="range" id="draw-size-input" min="1" max="50" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                        </div>
                    </div>
                </div>

                <!-- Page Background -->
                <div class="mb-6 border-t border-slate-200 dark:border-slate-700 pt-4">
                    <h3 class="text-lg font-medium text-slate-700 dark:text-slate-300 mb-3">Page Background</h3>
                    <div class="flex items-center space-x-2">
                        <label for="bg-color-input" class="text-sm font-medium text-slate-700 dark:text-slate-400">Color:</label>
                        <input type="color" id="bg-color-input" value="#ffffff" class="w-10 h-10 rounded-md border-slate-300 dark:border-slate-600 shadow-sm">
                    </div>
                    <button id="apply-bg-btn" class="w-full mt-3 text-sm bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300">Apply to Current Page</button>
                    <button id="remove-bg-btn" class="w-full mt-2 text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-300 font-semibold py-2 px-4 rounded-lg transition duration-300">Remove from Current Page</button>
                </div>

                <!-- Edit Selected Element -->
                <div id="edit-panel" class="mb-6 hidden">
                    <h3 class="text-lg font-medium text-slate-700 dark:text-slate-300 mb-3 border-t border-slate-200 dark:border-slate-700 pt-4">Edit Element</h3>
                    <div id="text-controls" class="space-y-4"></div>
                    <div id="image-controls" class="space-y-3"></div>
                    <button id="delete-btn" class="w-full mt-6 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Delete Element</button>
                </div>

                <!-- Save -->
                <div>
                    <h3 class="text-lg font-medium text-slate-700 dark:text-slate-300 mb-3 border-t border-slate-200 dark:border-slate-700 pt-4">Save PDF</h3>
                    <button id="save-pdf-btn" class="w-full bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Save & Download</button>
                </div>
            </aside>

            <!-- PDF Display Area -->
            <main id="pdf-viewer-main" class="lg:col-span-3"></main>
        </div>
    </div>
        
    <!-- Signature Modal -->
    <div id="signature-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden"></div>
    
    <!-- Loading Indicator -->
    <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="text-white text-xl">Processing...</div>
    </div>

    <script>
        // --- PDF.js and PDF-lib setup ---
        const { PDFDocument, rgb, StandardFonts, drawRectangle, drawLine } = PDFLib;
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // --- DOM Element References ---
        const initialPdfUpload = document.getElementById('initial-pdf-upload');
        const uploadScreen = document.getElementById('upload-screen');
        const mainEditor = document.getElementById('main-editor');
        const pdfViewerMain = document.getElementById('pdf-viewer-main');
        const pdfFilename = document.getElementById('pdf-filename');
        const loadNewPdfBtn = document.getElementById('load-new-pdf-btn');
        const themeSwitch = document.getElementById('theme-switch');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        
        // --- Mode controls ---
        const selectModeBtn = document.getElementById('select-mode-btn');
        const drawModeBtn = document.getElementById('draw-mode-btn');
        const addElementsPanel = document.getElementById('add-elements-panel');
        const drawSettingsPanel = document.getElementById('draw-settings-panel');
        const drawColorInput = document.getElementById('draw-color-input');
        const drawSizeInput = document.getElementById('draw-size-input');
        const matchBgBtn = document.getElementById('match-bg-btn');

        const imageUpload = document.getElementById('image-upload');
        const addTextBtn = document.getElementById('add-text-btn');
        const addSignatureBtn = document.getElementById('add-signature-btn');
        const savePdfBtn = document.getElementById('save-pdf-btn');
        
        // --- Background Controls ---
        const bgColorInput = document.getElementById('bg-color-input');
        const applyBgBtn = document.getElementById('apply-bg-btn');
        const removeBgBtn = document.getElementById('remove-bg-btn');

        // --- Edit Panel ---
        const editPanel = document.getElementById('edit-panel');
        const textControls = document.getElementById('text-controls');
        const imageControls = document.getElementById('image-controls');
        const deleteBtn = document.getElementById('delete-btn');

        // --- Signature Modal ---
        const signatureModal = document.getElementById('signature-modal');
        
        const loadingOverlay = document.getElementById('loading-overlay');

        // --- Application State ---
        let pdfDoc = null;
        let currentPageNum = 1;
        let pageRendering = false;
        let pageNumPending = null;
        let originalPdfBytes = null;
        let objects = [];
        let pageBackgroundColors = {};
        let selectedObject = null;
        let currentMode = 'select'; // 'select' or 'draw'
        let isDragging = false;
        let isResizing = false;
        let isDrawing = false;
        let isSigning = false;
        let resizeHandle = null;
        let dragOffsetX, dragOffsetY;
        let lastX, lastY;
        let currentRenderScale = 1;
        let signatureIsEmpty = true;
        let currentPath = null;
        let objectsCanvas, pdfCanvas, pdfCtx, objectsCtx;
        let history = [];
        let redoStack = [];

        // --- History (Undo/Redo) Functions ---
        function saveState() {
            redoStack = []; // Clear redo stack on new action
            updateHistoryButtons();

            const serializableObjects = objects.map(o => {
                const newO = {...o};
                if (newO.image) {
                    delete newO.image; // Don't store the live DOM element
                }
                return newO;
            });

            history.push({
                objects: JSON.parse(JSON.stringify(serializableObjects)),
                pageBackgroundColors: JSON.parse(JSON.stringify(pageBackgroundColors))
            });
            updateHistoryButtons();
        }

        function restoreState(state) {
            pageBackgroundColors = state.pageBackgroundColors;
            
            const objectPromises = state.objects.map(obj => {
                if (obj.type === 'image') {
                    return new Promise(resolve => {
                        const img = new Image();
                        img.onload = () => resolve({...obj, image: img});
                        img.onerror = () => resolve(null); 
                        img.src = obj.base64;
                    });
                }
                return Promise.resolve(obj);
            });

            Promise.all(objectPromises).then(restoredObjects => {
                objects = restoredObjects.filter(Boolean);
                selectedObject = null;
                updateEditPanel();
                renderPage(currentPageNum);
            });
        }

        function undo() {
            if (history.length === 0) return;

            const currentStateSerializable = objects.map(o => {
                const newO = {...o};
                if (newO.image) delete newO.image;
                return newO;
            });
            redoStack.push({
                objects: JSON.parse(JSON.stringify(currentStateSerializable)),
                pageBackgroundColors: JSON.parse(JSON.stringify(pageBackgroundColors))
            });

            const lastState = history.pop();
            restoreState(lastState);
            updateHistoryButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;

            const currentStateSerializable = objects.map(o => {
                const newO = {...o};
                if (newO.image) delete newO.image;
                return newO;
            });
            history.push({
                objects: JSON.parse(JSON.stringify(currentStateSerializable)),
                pageBackgroundColors: JSON.parse(JSON.stringify(pageBackgroundColors))
            });

            const nextState = redoStack.pop();
            restoreState(nextState);
            updateHistoryButtons();
        }

        function updateHistoryButtons() {
            undoBtn.disabled = history.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }

        // --- Core Functions ---
        function setupCanvas() {
            pdfViewerMain.innerHTML = `
                <div id="canvas-wrapper">
                    <canvas id="pdf-canvas"></canvas>
                    <canvas id="objects-canvas"></canvas>
                </div>
                <div class="flex justify-between items-center mt-4 bg-white dark:bg-slate-800 p-2 rounded-lg shadow-md">
                    <button id="prev-page" class="px-4 py-2 bg-slate-200 dark:bg-slate-700 dark:hover:bg-slate-600 rounded-md disabled:opacity-50">&lt; Prev</button>
                    <span class="text-slate-700 dark:text-slate-300">Page: <span id="page-num">0</span> / <span id="page-count">0</span></span>
                    <button id="next-page" class="px-4 py-2 bg-slate-200 dark:bg-slate-700 dark:hover:bg-slate-600 rounded-md disabled:opacity-50">Next &gt;</button>
                </div>`;
            
            pdfCanvas = document.getElementById('pdf-canvas');
            objectsCanvas = document.getElementById('objects-canvas');
            pdfCtx = pdfCanvas.getContext('2d');
            objectsCtx = objectsCanvas.getContext('2d');

            document.getElementById('prev-page').addEventListener('click', () => { if (currentPageNum > 1) { currentPageNum--; queueRenderPage(currentPageNum); } });
            document.getElementById('next-page').addEventListener('click', () => { if (currentPageNum < pdfDoc.numPages) { currentPageNum++; queueRenderPage(currentPageNum); } });
            
            objectsCanvas.addEventListener('mousedown', handleMouseDown);
            objectsCanvas.addEventListener('mousemove', handleMouseMove);
            objectsCanvas.addEventListener('mouseup', handleMouseUp);
            objectsCanvas.addEventListener('mouseleave', handleMouseUp);
        }

        function setupSignatureModal() {
            signatureModal.innerHTML = `
                <div class="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-xl w-full max-w-md">
                    <h3 class="text-xl font-semibold mb-4 text-slate-900 dark:text-slate-100">Create Signature</h3>
                    <canvas id="signature-canvas" width="400" height="200"></canvas>
                    <div class="flex items-center justify-between mt-4">
                        <div>
                            <label for="signature-color" class="text-sm font-medium mr-2 text-slate-700 dark:text-slate-300">Ink Color:</label>
                            <input type="color" id="signature-color" value="#000000">
                        </div>
                        <button id="clear-signature-btn" class="text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-300 font-semibold py-2 px-4 rounded-lg">Clear</button>
                    </div>
                    <div class="flex justify-end space-x-3 mt-6">
                        <button id="cancel-signature-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 dark:bg-slate-600 dark:hover:bg-slate-500 dark:text-slate-200 font-bold py-2 px-4 rounded-lg">Cancel</button>
                        <button id="save-signature-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Save Signature</button>
                    </div>
                </div>`;
            
            const signatureCanvas = document.getElementById('signature-canvas');
            const signatureCtx = signatureCanvas.getContext('2d');
            document.getElementById('cancel-signature-btn').addEventListener('click', () => signatureModal.classList.add('hidden'));
            document.getElementById('clear-signature-btn').addEventListener('click', () => {
                signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
                signatureIsEmpty = true;
            });
            document.getElementById('save-signature-btn').addEventListener('click', () => saveSignature(signatureCanvas));
            
            const startSign = (e) => { e.preventDefault(); isSigning = true; const pos = getPaintPosition(e, signatureCanvas); lastX = pos.x; lastY = pos.y; };
            const drawSign = (e) => {
                if (!isSigning) return;
                e.preventDefault(); const pos = getPaintPosition(e, signatureCanvas);
                signatureCtx.beginPath(); signatureCtx.lineWidth = 2; signatureCtx.lineCap = 'round';
                signatureCtx.strokeStyle = document.getElementById('signature-color').value;
                signatureCtx.moveTo(lastX, lastY); signatureCtx.lineTo(pos.x, pos.y);
                signatureCtx.stroke(); lastX = pos.x; lastY = pos.y; signatureIsEmpty = false;
            };
            const endSign = () => { isSigning = false; };

            signatureCanvas.addEventListener('mousedown', startSign);
            signatureCanvas.addEventListener('mousemove', drawSign);
            signatureCanvas.addEventListener('mouseup', endSign);
            signatureCanvas.addEventListener('mouseout', endSign);
        }

        async function renderPage(num) {
            pageRendering = true;
            loadingOverlay.classList.remove('hidden');
            const page = await pdfDoc.getPage(num);
            const unscaledViewport = page.getViewport({ scale: 1 });
            const availableWidth = pdfViewerMain.clientWidth;
            const scale = availableWidth / unscaledViewport.width;
            currentRenderScale = scale;
            const viewport = page.getViewport({ scale: scale });
            const devicePixelRatio = window.devicePixelRatio || 1;
            const outputScale = devicePixelRatio;
            pdfCanvas.width = Math.floor(viewport.width * outputScale);
            pdfCanvas.height = Math.floor(viewport.height * outputScale);
            objectsCanvas.width = pdfCanvas.width;
            objectsCanvas.height = pdfCanvas.height;
            pdfCanvas.style.width = `${Math.floor(viewport.width)}px`;
            pdfCanvas.style.height = `${Math.floor(viewport.height)}px`;
            objectsCanvas.style.width = pdfCanvas.style.width;
            objectsCanvas.style.height = pdfCanvas.style.height;
            document.getElementById('canvas-wrapper').style.height = `${Math.floor(viewport.height)}px`;
            const transform = [outputScale, 0, 0, outputScale, 0, 0];
            
            const backgroundColor = pageBackgroundColors[num] || '#ffffff';

            const renderContext = { canvasContext: pdfCtx, viewport: viewport, transform: transform, background: backgroundColor };
            await page.render(renderContext).promise;
            pageRendering = false;
            loadingOverlay.classList.add('hidden');
            if (pageNumPending !== null) { renderPage(pageNumPending); pageNumPending = null; }
            document.getElementById('page-num').textContent = num;
            bgColorInput.value = pageBackgroundColors[num] || '#ffffff';
            redrawObjects();
        }

        function queueRenderPage(num) { if (pageRendering) pageNumPending = num; else renderPage(num); }

        function getGenericFontFamily(fontFamily) {
            switch(fontFamily) {
                case 'Arial':
                case 'Verdana':
                case 'Helvetica':
                    return 'sans-serif';
                case 'Georgia':
                case 'TimesRoman':
                    return 'serif';
                case 'CourierNew':
                case 'LucidaConsole':
                case 'Courier':
                    return 'monospace';
                default:
                    return fontFamily; // For Symbol, ZapfDingbats
            }
        }

        function redrawObjects() {
            const devicePixelRatio = window.devicePixelRatio || 1;
            objectsCtx.clearRect(0, 0, objectsCanvas.width, objectsCanvas.height);
            const pageObjects = objects.filter(obj => obj.pageNum === currentPageNum);

            pageObjects.forEach(obj => {
                objectsCtx.save();
                if (obj.type === 'path') {
                    objectsCtx.strokeStyle = obj.color;
                    objectsCtx.lineWidth = obj.lineWidth * currentRenderScale * devicePixelRatio;
                    objectsCtx.lineCap = 'round';
                    objectsCtx.lineJoin = 'round';
                    objectsCtx.beginPath();
                    obj.points.forEach((p, i) => {
                        const canvasX = p.x * currentRenderScale * devicePixelRatio;
                        const canvasY = p.y * currentRenderScale * devicePixelRatio;
                        if (i === 0) objectsCtx.moveTo(canvasX, canvasY);
                        else objectsCtx.lineTo(canvasX, canvasY);
                    });
                    objectsCtx.stroke();
                } else {
                    const canvasX = obj.x * currentRenderScale * devicePixelRatio;
                    const canvasY = obj.y * currentRenderScale * devicePixelRatio;
                    if (obj.type === 'text') {
                        const fontStyle = `${obj.italic ? 'italic' : ''} ${obj.bold ? 'bold' : ''}`;
                        const canvasFontSize = obj.fontSize * currentRenderScale * devicePixelRatio;
                        const genericFont = getGenericFontFamily(obj.fontFamily);
                        objectsCtx.font = `${fontStyle} ${canvasFontSize}px ${genericFont}`;
                        
                        const metrics = objectsCtx.measureText(obj.content);
                        obj.width = (metrics.width / devicePixelRatio) / currentRenderScale;
                        const fontHeight = (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
                        obj.height = fontHeight / devicePixelRatio / currentRenderScale;

                        if (obj.highlight) {
                            objectsCtx.fillStyle = 'rgba(255, 255, 0, 0.4)';
                            objectsCtx.fillRect(canvasX, canvasY - fontHeight, metrics.width, fontHeight);
                        }

                        objectsCtx.fillStyle = obj.color;
                        objectsCtx.fillText(obj.content, canvasX, canvasY);

                        if (obj.underline) {
                            objectsCtx.fillRect(canvasX, canvasY + (2 * devicePixelRatio), metrics.width, 1 * devicePixelRatio);
                        }

                    } else if (obj.type === 'image') {
                        const canvasWidth = obj.width * currentRenderScale * devicePixelRatio;
                        const canvasHeight = obj.height * currentRenderScale * devicePixelRatio;
                        objectsCtx.drawImage(obj.image, canvasX, canvasY, canvasWidth, canvasHeight);
                    }

                    if (obj === selectedObject) {
                        objectsCtx.strokeStyle = '#3b82f6';
                        objectsCtx.lineWidth = 2 * devicePixelRatio;
                        objectsCtx.setLineDash([5, 5]);
                        const boxX = canvasX;
                        const boxY = (obj.type === 'text') ? (canvasY - obj.height * currentRenderScale * devicePixelRatio) : canvasY;
                        const boxW = obj.width * currentRenderScale * devicePixelRatio;
                        const boxH = obj.height * currentRenderScale * devicePixelRatio;
                        objectsCtx.strokeRect(boxX - 4, boxY - 4, boxW + 8, boxH + 8);
                        objectsCtx.setLineDash([]);
                        if (obj.type === 'image') {
                            objectsCtx.fillStyle = '#3b82f6';
                            const handleSize = 8 * devicePixelRatio;
                            objectsCtx.fillRect(boxX + boxW + 4 - (handleSize / 2), boxY + boxH + 4 - (handleSize / 2), handleSize, handleSize);
                        }
                    }
                }
                objectsCtx.restore();
            });
        }
        
        function updateEditPanel() {
            if (!selectedObject || currentMode === 'draw') {
                editPanel.classList.add('hidden');
                return;
            }
            editPanel.classList.remove('hidden');
            if (selectedObject.type === 'text') {
                textControls.innerHTML = `
                    <div><label for="text-input" class="block text-sm font-medium text-slate-700 dark:text-slate-400">Text Content</label><input type="text" id="text-input" value="${selectedObject.content}" class="mt-1 block w-full rounded-md border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"></div>
                    <div><label for="font-family-select" class="block text-sm font-medium text-slate-700 dark:text-slate-400">Font Family</label>
                        <select id="font-family-select" class="mt-1 block w-full rounded-md border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            <option value="Helvetica">Helvetica</option>
                            <option value="Arial">Arial</option>
                            <option value="Verdana">Verdana</option>
                            <option value="TimesRoman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Courier">Courier</option>
                            <option value="CourierNew">Courier New</option>
                            <option value="LucidaConsole">Lucida Console</option>
                            <option value="Symbol">Symbol</option>
                            <option value="ZapfDingbats">Zapf Dingbats</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-2 gap-4"><div><label for="font-size-input" class="block text-sm font-medium text-slate-700 dark:text-slate-400">Font Size</label><input type="number" id="font-size-input" value="${selectedObject.fontSize}" min="1" class="mt-1 block w-full rounded-md border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"></div><div><label for="color-input" class="block text-sm font-medium text-slate-700 dark:text-slate-400">Color</label><input type="color" id="color-input" value="${selectedObject.color}" class="mt-1 block w-full h-10 rounded-md border-slate-300 dark:border-slate-600 shadow-sm"></div></div>
                    <div><label class="block text-sm font-medium text-slate-700 dark:text-slate-400">Style</label><div class="mt-1 grid grid-cols-4 gap-px rounded-lg bg-gray-200 dark:bg-gray-700 shadow-sm" role="group">
                        <button type="button" data-style="bold" class="style-btn px-4 py-2 text-sm font-bold bg-white dark:bg-slate-800 text-gray-900 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-slate-700 rounded-l-lg">B</button>
                        <button type="button" data-style="italic" class="style-btn px-4 py-2 text-sm italic bg-white dark:bg-slate-800 text-gray-900 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-slate-700">I</button>
                        <button type="button" data-style="underline" class="style-btn px-4 py-2 text-sm underline bg-white dark:bg-slate-800 text-gray-900 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-slate-700">U</button>
                        <button type="button" data-style="highlight" class="style-btn px-4 py-2 text-sm bg-yellow-200 text-gray-900 hover:bg-yellow-300 rounded-r-lg">H</button>
                    </div></div>`;
                document.getElementById('font-family-select').value = selectedObject.fontFamily;
                document.querySelector('.style-btn[data-style="bold"]').classList.toggle('btn-toggle-active', selectedObject.bold);
                document.querySelector('.style-btn[data-style="italic"]').classList.toggle('btn-toggle-active', selectedObject.italic);
                document.querySelector('.style-btn[data-style="underline"]').classList.toggle('btn-toggle-active', selectedObject.underline);
                document.querySelector('.style-btn[data-style="highlight"]').classList.toggle('btn-toggle-active', selectedObject.highlight);
                imageControls.innerHTML = '';
            } else if (selectedObject.type === 'image') {
                textControls.innerHTML = '';
                imageControls.innerHTML = `<p class="text-sm text-slate-600 dark:text-slate-400">Click and drag the handle on the element to resize.</p>`;
            }
        }
        
        function getObjectAt(x, y) {
             const pageObjects = objects.filter(obj => obj.pageNum === currentPageNum && obj.type !== 'path');
             for (let i = pageObjects.length - 1; i >= 0; i--) {
                const obj = pageObjects[i];
                const objY = obj.type === 'text' ? obj.y - obj.height : obj.y;
                if (x >= obj.x && x <= obj.x + obj.width && y >= objY && y <= objY + obj.height) return obj;
            }
            return null;
        }

        function getHandleAt(x, y) {
            if (!selectedObject || selectedObject.type !== 'image') return null;
            const handleSize = 10 / currentRenderScale;
            const obj = selectedObject;
            const brHandleX = obj.x + obj.width;
            const brHandleY = obj.y + obj.height;
            if (x >= brHandleX - handleSize / 2 && x <= brHandleX + handleSize / 2 && y >= brHandleY - handleSize / 2 && y <= brHandleY + handleSize / 2) return 'bottom-right';
            return null;
        }

        // --- Event Handlers ---
        initialPdfUpload.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file || file.type !== 'application/pdf') { alert('Please select a valid PDF file.'); return; }
            loadingOverlay.classList.remove('hidden');
            originalPdfBytes = await file.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ data: originalPdfBytes });
            pdfDoc = await loadingTask.promise;
            document.getElementById('page-count').textContent = pdfDoc.numPages;
            pdfFilename.textContent = file.name;
            currentPageNum = 1;
            uploadScreen.classList.add('hidden');
            mainEditor.classList.remove('hidden');
            saveState();
            renderPage(currentPageNum);
        });
        
        loadNewPdfBtn.addEventListener('click', () => { window.location.reload(); });
        
        addTextBtn.addEventListener('click', () => {
            saveState();
            const newText = { type: 'text', content: 'New Text', x: 50, y: 50, fontSize: 24, fontFamily: 'Helvetica', color: '#000000', bold: false, italic: false, underline: false, highlight: false, pageNum: currentPageNum, width: 0, height: 0 };
            objects.push(newText);
            selectedObject = newText;
            updateEditPanel();
            redrawObjects();
        });

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file.type.startsWith('image/')) return;
            saveState();
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const aspectRatio = img.height / img.width;
                    const newImage = { type: 'image', image: img, x: 50, y: 50, width: 150, height: 150 * aspectRatio, pageNum: currentPageNum, base64: event.target.result, fileType: file.type };
                    objects.push(newImage);
                    selectedObject = newImage;
                    updateEditPanel();
                    redrawObjects();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        });

        function getPdfCoordinates(e) {
            const rect = objectsCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / currentRenderScale;
            const y = (e.clientY - rect.top) / currentRenderScale;
            return { x, y };
        }

        function handleMouseDown(e) {
            const { x, y } = getPdfCoordinates(e);
            if (currentMode === 'draw') {
                saveState();
                isDrawing = true;
                currentPath = { type: 'path', pageNum: currentPageNum, color: drawColorInput.value, lineWidth: drawSizeInput.value, points: [{x, y}] };
                objects.push(currentPath);
                redrawObjects();
                return;
            }
            resizeHandle = getHandleAt(x, y);
            if (resizeHandle) { saveState(); isResizing = true; isDragging = false; objectsCanvas.style.cursor = 'se-resize'; return; }
            const clickedObject = getObjectAt(x, y);
            if(clickedObject) saveState();
            selectedObject = clickedObject;
            if (selectedObject) { isDragging = true; dragOffsetX = x - selectedObject.x; dragOffsetY = y - selectedObject.y; objectsCanvas.style.cursor = 'move'; } 
            else { isDragging = false; }
            updateEditPanel();
            redrawObjects();
        }

        function handleMouseMove(e) {
            const { x, y } = getPdfCoordinates(e);
            if (isDrawing) {
                currentPath.points.push({x, y});
                redrawObjects();
                return;
            }
            if (currentMode !== 'select') return;
            if (isResizing && selectedObject) {
                const originalAspectRatio = selectedObject.image.height / selectedObject.image.width;
                const newWidth = x - selectedObject.x;
                if (newWidth > 10) { selectedObject.width = newWidth; selectedObject.height = newWidth * originalAspectRatio; }
                redrawObjects();
                return;
            }
            if (isDragging && selectedObject) { selectedObject.x = x - dragOffsetX; selectedObject.y = y - dragOffsetY; redrawObjects(); return; }
            
            const handle = getHandleAt(x, y);
            if (handle) objectsCanvas.style.cursor = 'se-resize';
            else if (getObjectAt(x, y)) objectsCanvas.style.cursor = 'move';
            else objectsCanvas.style.cursor = 'default';
        }

        function handleMouseUp() {
            if (isDrawing) { isDrawing = false; currentPath = null; }
            isDragging = false; isResizing = false; resizeHandle = null;
            if (currentMode === 'select') objectsCanvas.style.cursor = 'default';
        }

        editPanel.addEventListener('input', (e) => {
            if (!selectedObject) return;
            const target = e.target;
            if (target.id === 'text-input') selectedObject.content = target.value;
            else if (target.id === 'font-size-input') selectedObject.fontSize = parseInt(target.value, 10);
            redrawObjects();
        });
        editPanel.addEventListener('change', (e) => {
            if (!selectedObject) return;
            const target = e.target;
            if (target.id === 'font-family-select') selectedObject.fontFamily = target.value;
            else if (target.id === 'color-input') selectedObject.color = target.value;
            saveState();
            redrawObjects();
        });
        editPanel.addEventListener('click', (e) => {
            if (!selectedObject || !e.target.matches('.style-btn')) return;
            const style = e.target.dataset.style;
            selectedObject[style] = !selectedObject[style];
            e.target.classList.toggle('btn-toggle-active', selectedObject[style]);
            saveState();
            redrawObjects();
        });
        
        deleteBtn.addEventListener('click', () => {
            if (!selectedObject) return;
            saveState();
            const index = objects.indexOf(selectedObject);
            if (index > -1) objects.splice(index, 1);
            selectedObject = null;
            updateEditPanel();
            redrawObjects();
        });

        savePdfBtn.addEventListener('click', async () => {
            if (!originalPdfBytes) return;
            loadingOverlay.classList.remove('hidden');
            
            try {
                const newPdfDoc = await PDFDocument.create();
                const originalPdfDoc = await PDFDocument.load(originalPdfBytes);
                
                const fontMapping = {
                    Helvetica: { regular: StandardFonts.Helvetica, bold: StandardFonts.HelveticaBold, italic: StandardFonts.HelveticaOblique, bolditalic: StandardFonts.HelveticaBoldOblique },
                    TimesRoman: { regular: StandardFonts.TimesRoman, bold: StandardFonts.TimesRomanBold, italic: StandardFonts.TimesRomanItalic, bolditalic: StandardFonts.TimesRomanBoldItalic },
                    Courier: { regular: StandardFonts.Courier, bold: StandardFonts.CourierBold, italic: StandardFonts.CourierOblique, bolditalic: StandardFonts.CourierBoldOblique },
                    Symbol: { regular: StandardFonts.Symbol },
                    ZapfDingbats: { regular: StandardFonts.ZapfDingbats }
                };
                const embeddedFonts = {};
                for (const font in fontMapping) {
                    embeddedFonts[font] = {};
                    for (const style in fontMapping[font]) {
                        embeddedFonts[font][style] = await newPdfDoc.embedFont(fontMapping[font][style]);
                    }
                }

                const embeddedPages = await newPdfDoc.embedPages(originalPdfDoc.getPages());

                for (let i = 0; i < embeddedPages.length; i++) {
                    const pageNum = i + 1;
                    const embeddedPage = embeddedPages[i];
                    
                    const newPage = newPdfDoc.addPage([embeddedPage.width, embeddedPage.height]);
                    const { width, height } = newPage.getSize();

                    // 1. Draw background color FIRST
                    const bgColorHex = pageBackgroundColors[pageNum];
                    if (bgColorHex) {
                        const r = parseInt(bgColorHex.slice(1, 3), 16) / 255;
                        const g = parseInt(bgColorHex.slice(3, 5), 16) / 255;
                        const b = parseInt(bgColorHex.slice(5, 7), 16) / 255;
                        newPage.drawRectangle({ x: 0, y: 0, width, height, color: rgb(r, g, b) });
                    }

                    // 2. Draw the original page content ON TOP of the background
                    newPage.drawPage(embeddedPage);

                    // 3. Draw user-added objects on top of everything
                    const pageObjects = objects.filter(obj => obj.pageNum === pageNum);
                    for (const obj of pageObjects) {
                        if (obj.type === 'path') {
                            const { color, lineWidth, points } = obj;
                            const r = parseInt(color.slice(1, 3), 16) / 255, g = parseInt(color.slice(3, 5), 16) / 255, b = parseInt(color.slice(5, 7), 16) / 255;
                            for(let j = 1; j < points.length; j++) {
                                newPage.drawLine({ start: { x: points[j-1].x, y: height - points[j-1].y }, end: { x: points[j].x, y: height - points[j].y }, thickness: Number(lineWidth), color: rgb(r, g, b), lineCap: 'Round' });
                            }
                        } else {
                            const pdfY = height - obj.y;
                            if (obj.type === 'text') {
                                const { fontFamily, bold, italic } = obj;
                                let baseFontFamily;
                                switch(fontFamily) {
                                    case 'Arial': case 'Verdana': case 'Helvetica': baseFontFamily = 'Helvetica'; break;
                                    case 'Georgia': case 'TimesRoman': baseFontFamily = 'TimesRoman'; break;
                                    case 'CourierNew': case 'LucidaConsole': case 'Courier': baseFontFamily = 'Courier'; break;
                                    default: baseFontFamily = fontFamily;
                                }

                                let style = 'regular';
                                if (fontMapping[baseFontFamily].bolditalic && bold && italic) style = 'bolditalic';
                                else if (fontMapping[baseFontFamily].bold && bold) style = 'bold';
                                else if (fontMapping[baseFontFamily].italic && italic) style = 'italic';
                                
                                const fontToUse = embeddedFonts[baseFontFamily][style];
                                const { color, content, x, fontSize, underline, highlight } = obj;
                                const textWidth = fontToUse.widthOfTextAtSize(content, fontSize);
                                const textHeight = fontToUse.heightAtSize(fontSize);
                                if (highlight) {
                                    newPage.drawRectangle({ x, y: pdfY - textHeight + (textHeight - fontSize), width: textWidth, height: textHeight, color: rgb(1, 1, 0), opacity: 0.4 });
                                }
                                const r = parseInt(color.slice(1, 3), 16) / 255, g = parseInt(color.slice(3, 5), 16) / 255, b = parseInt(color.slice(5, 7), 16) / 255;
                                newPage.drawText(content, { x, y: pdfY, font: fontToUse, size: fontSize, color: rgb(r, g, b) });
                                if (underline) {
                                    newPage.drawLine({ start: { x, y: pdfY - 2 }, end: { x: x + textWidth, y: pdfY - 2 }, thickness: 0.5, color: rgb(r, g, b) });
                                }
                            } else if (obj.type === 'image') {
                                let embeddedImage;
                                if (obj.fileType === 'image/png' || obj.base64.startsWith('data:image/png')) embeddedImage = await newPdfDoc.embedPng(obj.base64);
                                else embeddedImage = await newPdfDoc.embedJpg(obj.base64);
                                newPage.drawImage(embeddedImage, { x: obj.x, y: pdfY - obj.height, width: obj.width, height: obj.height });
                            }
                        }
                    }
                }

                const pdfBytes = await newPdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'edited-document.pdf';
                link.click();
            } catch (err) {
                console.error("Failed to save PDF:", err);
                alert("An error occurred while saving the PDF. Please check the console for details.");
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        });
        
        window.addEventListener('resize', () => { if (pdfDoc) setTimeout(() => renderPage(currentPageNum), 200); });

        // --- Signature Logic ---
        function getPaintPosition(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            const event = e.touches ? e.touches[0] : e;
            return { x: event.clientX - rect.left, y: event.clientY - rect.top };
        }
        function saveSignature(canvas) {
            if (signatureIsEmpty) { alert("Please draw a signature first."); return; }
            saveState();
            const signatureImageURL = canvas.toDataURL('image/png');
            const img = new Image();
            img.onload = () => {
                const aspectRatio = img.height / img.width;
                const newSignature = { type: 'image', image: img, x: 50, y: 50, width: 150, height: 150 * aspectRatio, pageNum: currentPageNum, base64: signatureImageURL, fileType: 'image/png' };
                objects.push(newSignature);
                selectedObject = newSignature;
                updateEditPanel(); redrawObjects(); signatureModal.classList.add('hidden');
            };
            img.src = signatureImageURL;
        }
        addSignatureBtn.addEventListener('click', () => { signatureModal.classList.remove('hidden'); signatureIsEmpty = true; });
        
        // --- Theme Switcher Logic ---
        function toggleTheme() {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('color-theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            if (pdfDoc) {
                renderPage(currentPageNum);
            }
        }
        // Set the toggle state based only on what's in localStorage
        if (localStorage.getItem('color-theme') === 'dark') {
            themeSwitch.checked = true;
        }
        themeSwitch.addEventListener('change', toggleTheme);
        
        // --- Background Color Logic ---
        applyBgBtn.addEventListener('click', () => { if (pdfDoc) { saveState(); pageBackgroundColors[currentPageNum] = bgColorInput.value; renderPage(currentPageNum); } });
        removeBgBtn.addEventListener('click', () => { if (pdfDoc) { saveState(); delete pageBackgroundColors[currentPageNum]; renderPage(currentPageNum); } });

        // --- Mode Switching Logic ---
        function setMode(mode) {
            currentMode = mode;
            if (mode === 'select') {
                selectModeBtn.classList.add('btn-toggle-active');
                drawModeBtn.classList.remove('btn-toggle-active');
                addElementsPanel.classList.remove('hidden');
                drawSettingsPanel.classList.add('hidden');
                objectsCanvas.classList.remove('draw-mode');
                selectedObject = null;
                updateEditPanel();
                redrawObjects();
            } else { // draw mode
                selectModeBtn.classList.remove('btn-toggle-active');
                drawModeBtn.classList.add('btn-toggle-active');
                addElementsPanel.classList.add('hidden');
                drawSettingsPanel.classList.remove('hidden');
                objectsCanvas.classList.add('draw-mode');
                selectedObject = null;
                updateEditPanel();
                redrawObjects();
            }
        }
        selectModeBtn.addEventListener('click', () => setMode('select'));
        drawModeBtn.addEventListener('click', () => setMode('draw'));
        matchBgBtn.addEventListener('click', () => {
            drawColorInput.value = pageBackgroundColors[currentPageNum] || '#ffffff';
        });

        // --- Initial Setup ---
        setupCanvas();
        setupSignatureModal();
        setMode('select');
        updateHistoryButtons();
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

    </script>
</body>
</html>
